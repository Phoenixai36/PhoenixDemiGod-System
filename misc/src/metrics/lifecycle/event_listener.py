"""
Container event listener for Docker and Podman.

This module provides event listeners that integrate with Docker and Podman APIs
to capture real-time container lifecycle events.
"""

import logging
import asyncio
import json
from datetime import datetime
from typing import Optional, Callable, Dict, Any, AsyncGenerator
from abc import ABC, abstractmethod

try:
    import docker
    DOCKER_AVAILABLE = True
except ImportError:
    DOCKER_AVAILABLE = False

try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
except ImportError:
    AIOHTTP_AVAILABLE = False

from .lifecycle_collector import ContainerLifecycleEvent, ContainerEvent


class ContainerEventListener(ABC):
    """Abstract base class for container event listeners."""
    
    def __init__(self, event_callback: Callable[[ContainerLifecycleEvent], None]):
        self.event_callback = event_callback
        self.logger = logging.getLogger(__name__)
        self._listening = False
        self._listen_task: Optional[asyncio.Task] = None
    
    @abstractmethod
    async def start_listening(self) -> None:
        """Start listening for container events."""
        pass
    
    @abstractmethod
    async def stop_listening(self) -> None:
        """Stop listening for container events."""
        pass
    
    @abstractmethod
    async def get_container_info(self, container_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get information about a specific container.\"\"\"\n        pass\n    \n    def _parse_event_type(self, event_action: str) -> Optional[ContainerEvent]:\n        \"\"\"Parse container event action to ContainerEvent enum.\"\"\"\n        action_mapping = {\n            \"start\": ContainerEvent.STARTED,\n            \"stop\": ContainerEvent.STOPPED,\n            \"restart\": ContainerEvent.RESTARTED,\n            \"die\": ContainerEvent.DIED,\n            \"kill\": ContainerEvent.KILLED,\n            \"pause\": ContainerEvent.PAUSED,\n            \"unpause\": ContainerEvent.UNPAUSED\n        }\n        return action_mapping.get(event_action.lower())\n\n\nclass DockerEventListener(ContainerEventListener):\n    \"\"\"Docker event listener using the Docker Python SDK.\"\"\"\n    \n    def __init__(self, event_callback: Callable[[ContainerLifecycleEvent], None],\n                 docker_client=None):\n        super().__init__(event_callback)\n        \n        if not DOCKER_AVAILABLE:\n            raise ImportError(\"Docker SDK not available. Install with: pip install docker\")\n        \n        self.docker_client = docker_client or docker.from_env()\n        self.logger = logging.getLogger(f\"{__name__}.DockerEventListener\")\n    \n    async def start_listening(self) -> None:\n        \"\"\"Start listening for Docker events.\"\"\"\n        if self._listening:\n            self.logger.warning(\"Already listening for Docker events\")\n            return\n        \n        self._listening = True\n        self._listen_task = asyncio.create_task(self._listen_for_events())\n        self.logger.info(\"Started listening for Docker events\")\n    \n    async def stop_listening(self) -> None:\n        \"\"\"Stop listening for Docker events.\"\"\"\n        if not self._listening:\n            return\n        \n        self._listening = False\n        if self._listen_task:\n            self._listen_task.cancel()\n            try:\n                await self._listen_task\n            except asyncio.CancelledError:\n                pass\n        \n        self.logger.info(\"Stopped listening for Docker events\")\n    \n    async def _listen_for_events(self) -> None:\n        \"\"\"Listen for Docker events in a separate thread.\"\"\"\n        try:\n            # Run Docker event listening in a thread pool since it's blocking\n            loop = asyncio.get_event_loop()\n            await loop.run_in_executor(None, self._blocking_event_listener)\n        except asyncio.CancelledError:\n            raise\n        except Exception as e:\n            self.logger.error(f\"Error listening for Docker events: {str(e)}\")\n            self._listening = False\n    \n    def _blocking_event_listener(self) -> None:\n        \"\"\"Blocking Docker event listener (runs in thread pool).\"\"\"\n        try:\n            # Listen for container events only\n            events = self.docker_client.events(\n                filters={\"type\": \"container\"},\n                decode=True\n            )\n            \n            for event in events:\n                if not self._listening:\n                    break\n                \n                try:\n                    self._process_docker_event(event)\n                except Exception as e:\n                    self.logger.error(f\"Error processing Docker event: {str(e)}\")\n                    \n        except Exception as e:\n            self.logger.error(f\"Error in Docker event stream: {str(e)}\")\n    \n    def _process_docker_event(self, event: Dict[str, Any]) -> None:\n        \"\"\"Process a Docker event and convert to ContainerLifecycleEvent.\"\"\"\n        try:\n            action = event.get(\"Action\", \"\")\n            event_type = self._parse_event_type(action)\n            \n            if event_type is None:\n                return  # Skip unknown event types\n            \n            container_id = event.get(\"Actor\", {}).get(\"ID\", \"\")\n            attributes = event.get(\"Actor\", {}).get(\"Attributes\", {})\n            container_name = attributes.get(\"name\", container_id[:12])\n            \n            # Parse timestamp\n            timestamp = datetime.fromtimestamp(event.get(\"time\", 0))\n            \n            # Extract exit code for stop/die events\n            exit_code = None\n            if action in [\"stop\", \"die\"]:\n                exit_code = attributes.get(\"exitCode\")\n                if exit_code is not None:\n                    try:\n                        exit_code = int(exit_code)\n                    except (ValueError, TypeError):\n                        exit_code = None\n            \n            # Create lifecycle event\n            lifecycle_event = ContainerLifecycleEvent(\n                container_id=container_id,\n                container_name=container_name,\n                event_type=event_type,\n                timestamp=timestamp,\n                exit_code=exit_code,\n                reason=attributes.get(\"reason\"),\n                metadata={\n                    \"image\": attributes.get(\"image\", \"\"),\n                    \"labels\": {k: v for k, v in attributes.items() if k.startswith(\"label.\")}\n                }\n            )\n            \n            # Call the callback\n            self.event_callback(lifecycle_event)\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing Docker event: {str(e)}\")\n    \n    async def get_container_info(self, container_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get information about a specific Docker container.\"\"\"\n        try:\n            container = self.docker_client.containers.get(container_id)\n            return {\n                \"id\": container.id,\n                \"name\": container.name,\n                \"status\": container.status,\n                \"image\": container.image.tags[0] if container.image.tags else str(container.image.id),\n                \"created\": container.attrs.get(\"Created\"),\n                \"started_at\": container.attrs.get(\"State\", {}).get(\"StartedAt\"),\n                \"finished_at\": container.attrs.get(\"State\", {}).get(\"FinishedAt\"),\n                \"exit_code\": container.attrs.get(\"State\", {}).get(\"ExitCode\"),\n                \"restart_count\": container.attrs.get(\"RestartCount\", 0),\n                \"labels\": container.labels or {}\n            }\n        except Exception as e:\n            self.logger.error(f\"Error getting Docker container info: {str(e)}\")\n            return None\n\n\nclass PodmanEventListener(ContainerEventListener):\n    \"\"\"Podman event listener using HTTP API.\"\"\"\n    \n    def __init__(self, event_callback: Callable[[ContainerLifecycleEvent], None],\n                 podman_socket: str = \"unix:///run/podman/podman.sock\"):\n        super().__init__(event_callback)\n        \n        if not AIOHTTP_AVAILABLE:\n            raise ImportError(\"aiohttp not available. Install with: pip install aiohttp\")\n        \n        self.podman_socket = podman_socket\n        self.session: Optional[aiohttp.ClientSession] = None\n        self.logger = logging.getLogger(f\"{__name__}.PodmanEventListener\")\n    \n    async def start_listening(self) -> None:\n        \"\"\"Start listening for Podman events.\"\"\"\n        if self._listening:\n            self.logger.warning(\"Already listening for Podman events\")\n            return\n        \n        self._listening = True\n        self.session = aiohttp.ClientSession(\n            connector=aiohttp.UnixConnector(path=self.podman_socket.replace(\"unix://\", \"\"))\n        )\n        self._listen_task = asyncio.create_task(self._listen_for_events())\n        self.logger.info(\"Started listening for Podman events\")\n    \n    async def stop_listening(self) -> None:\n        \"\"\"Stop listening for Podman events.\"\"\"\n        if not self._listening:\n            return\n        \n        self._listening = False\n        if self._listen_task:\n            self._listen_task.cancel()\n            try:\n                await self._listen_task\n            except asyncio.CancelledError:\n                pass\n        \n        if self.session:\n            await self.session.close()\n            self.session = None\n        \n        self.logger.info(\"Stopped listening for Podman events\")\n    \n    async def _listen_for_events(self) -> None:\n        \"\"\"Listen for Podman events via HTTP API.\"\"\"\n        try:\n            url = \"http://localhost/v1.0.0/libpod/events\"\n            params = {\"filters\": json.dumps({\"type\": [\"container\"]})}\n            \n            async with self.session.get(url, params=params) as response:\n                if response.status != 200:\n                    self.logger.error(f\"Failed to connect to Podman events API: {response.status}\")\n                    return\n                \n                async for line in response.content:\n                    if not self._listening:\n                        break\n                    \n                    try:\n                        event_data = json.loads(line.decode().strip())\n                        self._process_podman_event(event_data)\n                    except json.JSONDecodeError:\n                        continue\n                    except Exception as e:\n                        self.logger.error(f\"Error processing Podman event: {str(e)}\")\n                        \n        except asyncio.CancelledError:\n            raise\n        except Exception as e:\n            self.logger.error(f\"Error listening for Podman events: {str(e)}\")\n            self._listening = False\n    \n    def _process_podman_event(self, event: Dict[str, Any]) -> None:\n        \"\"\"Process a Podman event and convert to ContainerLifecycleEvent.\"\"\"\n        try:\n            action = event.get(\"Action\", \"\")\n            event_type = self._parse_event_type(action)\n            \n            if event_type is None:\n                return  # Skip unknown event types\n            \n            container_id = event.get(\"Actor\", {}).get(\"ID\", \"\")\n            attributes = event.get(\"Actor\", {}).get(\"Attributes\", {})\n            container_name = attributes.get(\"name\", container_id[:12])\n            \n            # Parse timestamp\n            timestamp = datetime.fromtimestamp(event.get(\"Time\", 0))\n            \n            # Extract exit code for stop/die events\n            exit_code = None\n            if action in [\"stop\", \"die\"]:\n                exit_code = attributes.get(\"exitCode\")\n                if exit_code is not None:\n                    try:\n                        exit_code = int(exit_code)\n                    except (ValueError, TypeError):\n                        exit_code = None\n            \n            # Create lifecycle event\n            lifecycle_event = ContainerLifecycleEvent(\n                container_id=container_id,\n                container_name=container_name,\n                event_type=event_type,\n                timestamp=timestamp,\n                exit_code=exit_code,\n                reason=attributes.get(\"reason\"),\n                metadata={\n                    \"image\": attributes.get(\"image\", \"\"),\n                    \"labels\": {k: v for k, v in attributes.items() if k.startswith(\"label.\")}\n                }\n            )\n            \n            # Call the callback\n            self.event_callback(lifecycle_event)\n            \n        except Exception as e:\n            self.logger.error(f\"Error processing Podman event: {str(e)}\")\n    \n    async def get_container_info(self, container_id: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get information about a specific Podman container.\"\"\"\n        try:\n            url = f\"http://localhost/v1.0.0/libpod/containers/{container_id}/json\"\n            \n            async with self.session.get(url) as response:\n                if response.status != 200:\n                    return None\n                \n                data = await response.json()\n                state = data.get(\"State\", {})\n                config = data.get(\"Config\", {})\n                \n                return {\n                    \"id\": data.get(\"Id\"),\n                    \"name\": data.get(\"Name\", \"\").lstrip(\"/\"),\n                    \"status\": state.get(\"Status\"),\n                    \"image\": config.get(\"Image\"),\n                    \"created\": data.get(\"Created\"),\n                    \"started_at\": state.get(\"StartedAt\"),\n                    \"finished_at\": state.get(\"FinishedAt\"),\n                    \"exit_code\": state.get(\"ExitCode\"),\n                    \"restart_count\": data.get(\"RestartCount\", 0),\n                    \"labels\": config.get(\"Labels\", {})\n                }\n        except Exception as e:\n            self.logger.error(f\"Error getting Podman container info: {str(e)}\")\n            return None\n\n\nclass EventListenerFactory:\n    \"\"\"Factory for creating container event listeners.\"\"\"\n    \n    @staticmethod\n    def create_listener(runtime: str, event_callback: Callable[[ContainerLifecycleEvent], None],\n                       **kwargs) -> ContainerEventListener:\n        \"\"\"Create a container event listener for the specified runtime.\"\"\"\n        if runtime.lower() == \"docker\":\n            return DockerEventListener(event_callback, **kwargs)\n        elif runtime.lower() == \"podman\":\n            return PodmanEventListener(event_callback, **kwargs)\n        else:\n            raise ValueError(f\"Unsupported container runtime: {runtime}\")\n    \n    @staticmethod\n    def get_available_runtimes() -> Dict[str, bool]:\n        \"\"\"Get available container runtimes.\"\"\"\n        return {\n            \"docker\": DOCKER_AVAILABLE,\n            \"podman\": AIOHTTP_AVAILABLE  # Podman requires aiohttp for HTTP API\n        }"